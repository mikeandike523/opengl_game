#version 420 compatibility
#define M_PI 3.1415926535897932384626433832795
layout(triangles) in;
layout(triangle_strip, max_vertices = 6) out;
uniform float FAR_PLANE;
uniform float NEAR_PLANE;
uniform float focalDistance;
uniform vec3 CAMERA_YPR;
uniform vec3 CAMERA_POS;
uniform float STANDARD_EPSILON;
uniform float top;
uniform float right;
out vec3 norm;
out vec3 orig;
	bool isInside(float x1, float y1, float x2, float y2, float x3, float y3, float x, float y)
{
	if (((y2 - y3)*(x1 - x3) + (x3 - x2)*(y1 - y3)) == 0)
		return false;
	float a = ((y2 - y3)*(x - x3) + (x3 - x2)*(y - y3)) /((y2 - y3)*(x1 - x3) + (x3 - x2)*(y1 - y3));
	float 	b =((y3 - y1)*(x - x3) + (x1 - x3)*(y - y3)) /((y2 - y3)*(x1 - x3) + (x3 - x2)*(y1 - y3));
	float c = 1 - a - b;
	if (a >= 0 && a <= 1 && c >= 0 && c <= 1 && b >= 0 && b <= 1) return true;
	return false;
}


	bool check_line_intersection(float p0_x, float p0_y, float p1_x, float p1_y,
		float p2_x, float p2_y, float p3_x, float p3_y)
	{
		

		float goal1 = p0_x - p2_x;
		float goal2 = p0_y - p2_y;

		float topleft = p0_x - p1_x;
		float bottomleft = p0_y - p1_y;
		float topright = p3_x - p2_x;
		float bottomright = p3_y - p2_y;

		float det = topleft * bottomright - topright * bottomleft;
		if (abs(det) < STANDARD_EPSILON){
			return false; //singular matrix no intersection
			
		}

		float u = (bottomright*goal1 - topright * goal2) / det;
		float v = (topleft*goal2 - bottomleft * goal1) / det;
		if (u >= 0 && u <= 1 && v >= 0 && v <= 1) {
		
			return true;
		}
	


		return false;
	}

	bool cull(float x1, float y1, float x2, float y2, float x3, float y3) {
		int toShow = 0;

		if (x1 >= -right  && x1 <= right&&y1 <= top && y1 >= -top) {
			toShow = 1;
			
			
		}
		if (x2 >= -right && x2 <= right && y2 <= top && y2 >= -top) {
			toShow = 1;
			
			
		}
		if (x3 >= -right && x3 <= right && y3 <= top && y3 >= -top) {
			toShow = 1;
			
			
		}






		if (check_line_intersection(-right, top, -right, -top, x1, y1, x2, y2)) {
			
			
			toShow = 1;
		}


		if (check_line_intersection(right, top, right, -top, x1, y1, x2, y2)) {
			
			
			toShow = 1;
		}


		if (check_line_intersection(-right, -top, right, -top, x1, y1, x2, y2)) {
			
			
			toShow = 1;
		}


		if (check_line_intersection(-right, top, right, top, x1, y1, x2, y2)) {
			
			
			toShow = 1;
		}




		if (check_line_intersection(-right, top, -right, -top, x2, y2, x3, y3)) {
			
			
			toShow = 1;
		}


		if (check_line_intersection(right, top, right, -top, x2, y2, x3, y3)) {
			
			
			toShow = 1;
		}


		if (check_line_intersection(-right, -top, right, -top, x2, y2, x3, y3)) {
			
			
			toShow = 1;
		}


		if (check_line_intersection(-right, top, right, top, x2, y2, x3, y3)) {
			
			
			toShow = 1;
		}




		if (check_line_intersection(-right, top, -right, -top, x3, y3, x1, y1)) {
			
			
			toShow = 1;
		}


		if (check_line_intersection(right, top, right, -top, x3, y3, x1, y1)) {
			
			
			toShow = 1;
		}


		if (check_line_intersection(-right, -top, right, -top, x3, y3, x1, y1)) {
			
			
			toShow = 1;
		}


		if (check_line_intersection(-right, top, right, top, x3, y3, x1, y1)) {
			
			
			toShow = 1;
		}









		int toAddBackOriginal = 0;
		if (isInside(x1, y1, x2, y2, x3, y3, -right,top ))
		{
			toShow = 1;
			
		}
		if (isInside(x1, y1, x2, y2, x3, y3, right,top))
		{
			toShow = 1;
		
		}
		if (isInside(x1, y1, x2, y2, x3, y3, right,-top))
		{
			toShow = 1;
		

		}
		if (isInside(x1, y1, x2, y2, x3, y3, -right,-top))
		{
			toShow = 1;
			
		}




		if(toShow ==1)
		return true;
		return false;
	}

	mat3 eulerX(float angle){
		return transpose(mat3(
			1,0,0,
			0,cos(angle),-sin(angle),
			0,sin(angle),cos(angle)
		));
	}
	mat3 eulerY(float angle) {
		return transpose(mat3(
			cos(angle),0,sin(angle),
			0,1,0,
			-sin(angle),0,cos(angle)
		));
	}
	mat3 eulerZ(float angle) {
		return transpose(mat3(
		cos(angle),-sin(angle),0,
		sin(angle),cos(angle),0,
		0,0,1
		));
	}

	mat3 camRotMatrix(){
		return eulerY(CAMERA_YPR.x);
	}
	vec2 projPoint(vec3 pt){
		return focalDistance/pt.z*pt.xy;
	}
	vec4 makeVertex(vec2 pt,int i){
	  return gl_ModelViewProjectionMatrix * vec4(pt.xy,0,gl_in[i].gl_Position.w);
	}



int near_cut( vec3 i1, vec3 i2, vec3 i3,inout vec3 a1, inout vec3 a2, inout vec3 a3, inout vec3 b1, inout vec3 b2, inout vec3 b3) {
//rest of code works fine, need to write code here
int sum  = 0;
if(i1.z>FAR_PLANE&&i2.z>FAR_PLANE&&i3.z>FAR_PLANE)
return 0;
bool aisin = (i1.z>NEAR_PLANE);
if(aisin)
sum=sum+1;
bool bisin = (i2.z>NEAR_PLANE);
if(bisin)
sum=sum+1;
bool cisin = (i3.z>NEAR_PLANE);
if(cisin)
sum=sum+1;
if(sum==0)
return 0;
if(sum==3){
a1=i1;a2=i2;a3=i3; return 1;
}
if(sum==1){
	if(bisin){
		vec3 temp = i1;
		i1=i2;
		i2=temp;
	}
	if(cisin){
		vec3 temp = i1;
		i1=i3;
		i3=temp;
	}
	vec3 d1 = i2-i1;
	vec3 d2 = i3-i1;
	float t1 = (i1.z)/(i1.z-i2.z+NEAR_PLANE);
	float t2 = (i1.z)/(i1.z-i3.z+NEAR_PLANE);
	vec3 c1 = i1+d1*t1;
	vec3 c2 = i1+d2*t2;
	a1=i1;
	a2=c1;
	a3=c2;
	return 1;
}
if(sum==2){
		vec3 ni1,ni2,ni3;
	
	if(!bisin){
		vec3 temp = i1;
		i1=i2;
		i2=temp;
	}
	if(!cisin){
		vec3 temp = i1;
		i1=i3;
		i3=temp;
	}

		vec3 d1 = i1-i2;
	vec3 d2 = i1-i3;
	float t1 = (i2.z)/(i2.z-i1.z+NEAR_PLANE);
	float t2 = (i3.z)/(i3.z-i1.z+NEAR_PLANE);
	vec3 c1 = i2+d1*t1;
	vec3 c2 = i3+d2*t2;
	a1=i3;
	a2=c1;
	a3=c2;
	b1 = c1;
	b2= i2;
   b3=i3;


	return 2;


}




	return 0;
}






	void rendGoodNPCutTr(vec3 pt1, vec3 pt2, vec3 pt3){
		vec2 pt2d1 = projPoint(pt1);
	vec2 pt2d2 = projPoint(pt2);
	vec2 pt2d3 = projPoint(pt3);

	if(!cull(pt2d1.x,pt2d1.y,pt2d2.x,pt2d2.y,pt2d3.x,pt2d3.y))
	return;

	norm=cross(pt2-pt1,pt3-pt1);
	orig=pt1;
	gl_Position = makeVertex(pt2d1,0);
		EmitVertex();
gl_Position = makeVertex(pt2d2,1);
		EmitVertex();
gl_Position = makeVertex(pt2d3,2);
		EmitVertex();
	EndPrimitive();
	}

	void rendTr(vec3 pt1, vec3 pt2, vec3 pt3){
		vec3 x1,y1,z1,x2,y2,z2;
	int numtrs = near_cut(pt1,pt2,pt3,x1,y1,z1,x2,y2,z2);

		if(numtrs==1){
		rendGoodNPCutTr(x1,y1,z1);
	}
	if(numtrs==2){
		rendGoodNPCutTr(x1,y1,z1);
			rendGoodNPCutTr(x2,y2,z2);
	}

	}

void main(){
	
	mat3 crm = camRotMatrix();
	
        vec3 trA = crm*(gl_in[0].gl_Position.xyz-vec3(-CAMERA_POS.z,CAMERA_POS.y,CAMERA_POS.x));
		
        vec3 trB =crm*(gl_in[1].gl_Position.xyz-vec3(-CAMERA_POS.z,CAMERA_POS.y,CAMERA_POS.x));
	
        vec3 trC = crm*(gl_in[2].gl_Position.xyz-vec3(-CAMERA_POS.z,CAMERA_POS.y,CAMERA_POS.x));
	
	
 rendTr(trA,trB,trC);


}

